{
  "calculate_distinct_remainders_sum": {
    "code": "def calculate_distinct_remainders_sum(start, end, modulus):\n    if end < start:\n        return 0\n    distinct_remainders = set()\n    for n in range(start, end + 1):\n        square = n**2\n        remainder = square % modulus\n        distinct_remainders.add(remainder)\n    return sum(distinct_remainders), distinct_remainders",
    "packages": "sympy"
  },
  "convert_decimal_to_base": {
    "code": "def convert_decimal_to_base(number, base):\n    if base <= 1:\n        return 'Base must be greater than 1'\n    if number == 0:\n        return str(0)\n    digits = []\n    while number:\n        digits.append(int(number % base))\n        number //= base\n    return ''.join(str(x) for x in digits[::-1])",
    "packages": ""
  },
  "convert_from_decimal": {
    "code": "def convert_from_decimal(number, base):\n    if number < 0:\n        return '-' + convert_from_decimal(-number, base)\n    if base <= 1:\n        return 'Base must be greater than 1'\n    if number == 0:\n        return '0'\n    digits = []\n    while number:\n        digits.append(int(number % base))\n        number //= base\n    return ''.join(str(x) for x in digits[::-1])",
    "packages": ""
  },
  "find_last_digit_in_base": {
    "code": "def find_last_digit_in_base(number, base):\n    return number % base",
    "packages": ""
  },
  "modular_exponentiation": {
    "code": "def modular_exponentiation(base, exponent, modulus):\n    return pow(base, exponent, modulus)",
    "packages": ""
  },
  "modular_inverse": {
    "code": "def modular_inverse(a, m):\n    if a < 1 or m <= 1:\n        return None  # Inverse doesn't exist if a is less than 1 or modulus is less than or equal to 1\n    gcd, x, _ = sp.gcdex(a, m)\n    return x % m if gcd == 1 else None",
    "packages": "sympy"
  }
}