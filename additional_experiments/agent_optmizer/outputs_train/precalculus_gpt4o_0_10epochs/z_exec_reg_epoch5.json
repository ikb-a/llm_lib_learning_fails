{
  "evaluate_cross_product": {
    "code": "from sympy import Matrix\n\ndef evaluate_cross_product(vector_a, vector_b):\n    try:\n        vec_a = Matrix(vector_a)\n        vec_b = Matrix(vector_b)\n        cross_product = vec_a.cross(vec_b)\n        return list(cross_product)\n    except Exception as e:\n        return str(e)",
    "packages": "sympy"
  },
  "evaluate_math_expressions": {
    "code": "from sympy import sympify, simplify, SympifyError\n\ndef evaluate_math_expressions(expression):\n    try:\n        # Convert the expression into a sympy expression\n        expr = sympify(expression)\n        \n        # Simplify the expression to its simplest exact form\n        # Ensure result being evaluated can handle fractions/radicals as needed\n        result = simplify(expr)\n\n        if hasattr(result, 'evalf') and result.is_number:\n            return result.evalf()\n\n        return str(result)\n    except SympifyError as e:\n        return f\"Error simplifying expression: {e}\"",
    "packages": "sympy"
  },
  "evaluate_matrix_expression": {
    "code": "from sympy import Matrix\n\ndef evaluate_matrix_expression(matrix_a, matrix_b=None, operation='multiply'):\n    try:\n        mat_a = Matrix(matrix_a)\n        if operation == 'invert':\n            result = mat_a.inv()\n        elif operation == 'add' and matrix_b is not None:\n            mat_b = Matrix(matrix_b)\n            result = mat_a + mat_b\n        elif operation == 'multiply' and matrix_b is not None:\n            mat_b = Matrix(matrix_b)\n            result = mat_a * mat_b\n        else:\n            return 'Unsupported operation or missing matrix for operation.'\n        return result.tolist()\n    except Exception as e:\n        return str(e)",
    "packages": "sympy"
  },
  "evaluate_trig_expressions": {
    "code": "from sympy import sympify, simplify, rad, deg, pi, sin, cos, tan, asin, acos, atan, Rational\nfrom sympy.parsing.sympy_parser import standard_transformations, implicit_multiplication_application\n\ntransformations = (standard_transformations + (implicit_multiplication_application,))\n\ndef evaluate_trig_expressions(expression):\n    try:\n        # Handle transformations\n        expression = sympify(expression, transformations=transformations)\n        # Convert to degrees if expression contains degree sign\n        if '\u00b0' in str(expression) or 'degrees' in str(expression):\n            expression = expression.replace('\u00b0', '*pi/180').replace('degrees', '*pi/180')\n            expression = sympify(expression)\n        # Evaluate expression as numerical value if possible\n        result = expression.evalf()\n        if isinstance(result, float):\n            return float(round(result, 15))  # Round to avoid floating point inaccuracies\n        # Simplify if symbolic result is needed\n        return simplify(expression)\n    except Exception as e:\n        return str(e)",
    "packages": "sympy"
  },
  "solve_math_problem": {
    "code": "from sympy import symbols, simplify, solve, diff, integrate, sin, cos, tan, acos, asin, atan, Eq, sympify\nimport re\n\ndef solve_math_problem(problem, variables=None):\n    try:\n        # Define symbols for variables if given\n        if variables:\n            vars = symbols(' '.join(variables))\n        else:\n            vars = symbols('x y z')  # Default symbols\n\n        # Basic simplification of problem statement\n        problem = re.sub(r'[^\\w\\s=,()\\-+*/.^]', '', problem).replace('\\n', ' ').strip()\n\n        # Handle computation tasks\n        results = []\n        tasks = re.split(r'(?i)(solve|compute|evaluate|simplify|factor|expand|differentiate|integrate|arcsin|arccos|arctan)', problem)\n        operation = None\n        for task in tasks:\n            task = task.strip().lower()\n            if task in ['solve', 'compute', 'evaluate', 'simplify', 'factor', 'expand', 'differentiate', 'integrate', 'arcsin', 'arccos', 'arctan']:\n                operation = task\n            elif operation:\n                try:\n                    expr = sympify(task)\n                    if operation == 'solve' and '=' in task:\n                        lhs, rhs = [sympify(side) for side in task.split('=')]\n                        result = solve(Eq(lhs, rhs), vars)\n                    elif operation == 'differentiate':\n                        result = [diff(expr, var) for var in vars]\n                    elif operation == 'integrate':\n                        result = [integrate(expr, var) for var in vars]\n                    elif operation == 'arcsin':\n                        result = asin(expr)\n                    elif operation == 'arccos':\n                        result = acos(expr)\n                    elif operation == 'arctan':\n                        result = atan(expr)\n                    else:\n                        result = simplify(expr)\n                    results.append(result)\n                except Exception as e:\n                    results.append(str(e))\n        return results if results else 'No computational steps resolved.'\n    except Exception as e:\n        return f'Error processing task: {e}'",
    "packages": "sympy"
  },
  "solve_trigonometric_identity": {
    "code": "from sympy import sin, cos, tan, simplify\n\ndef solve_trigonometric_identity(expression):\n    try:\n        expr = sympify(expression)\n        simplified_expr = simplify(expr)\n        return str(simplified_expr)\n    except Exception as e:\n        return str(e)",
    "packages": "sympy"
  }
}