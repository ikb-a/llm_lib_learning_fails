{
  "evaluate_inverse_trig_expressions": {
    "code": "from sympy import sympify, asin, acos, atan, pi, simplify\n\n\ndef evaluate_inverse_trig_expressions(expression):\n    try:\n        expr = sympify(expression)\n        result = expr.evalf()\n        if isinstance(expr, (asin, acos, atan)):\n            return simplify(expr)\n        return result\n    except Exception as e:\n        return str(e)",
    "packages": "sympy"
  },
  "evaluate_math_expressions": {
    "code": "from sympy import sympify, simplify, SympifyError\n\ndef evaluate_math_expressions(expression):\n    try:\n        # Convert the expression into a sympy expression\n        expr = sympify(expression)\n        \n        # Simplify the expression to its simplest exact form\n        # Ensure result being evaluated can handle fractions/radicals as needed\n        result = simplify(expr)\n\n        if hasattr(result, 'evalf') and result.is_number:\n            return result.evalf()\n\n        return str(result)\n    except SympifyError as e:\n        return f\"Error simplifying expression: {e}\"",
    "packages": "sympy"
  },
  "evaluate_trig_expressions": {
    "code": "from sympy import sympify, simplify, rad, deg, cos, sin, tan\nfrom sympy.parsing.sympy_parser import standard_transformations, implicit_multiplication_application\n\ntransformations = (standard_transformations + (implicit_multiplication_application,))\n\ndef evaluate_trig_expressions(expression):\n    try:\n        # Handle transformations and support both radians and degrees\n        if '\u00b0' in expression or 'degrees' in expression:\n            expression = expression.replace('\u00b0', '*pi/180').replace('degrees', '*pi/180')\n        expr = sympify(expression, transformations=transformations)\n        result = simplify(expr)\n        return result\n    except Exception as e:\n        return str(e)",
    "packages": "sympy"
  },
  "solve_math_problem": {
    "code": "import sympy as sp\nimport re\n\ndef solve_math_problem(problem, variables=None):\n    try:\n        # Define symbols for the variables if provided\n        if variables:\n            vars = sp.symbols(' '.join(variables))\n        else:\n            vars = sp.symbols('x y z')  # Default symbols\n\n        # Identify matrix operations from the problem\n        if 'cross' in problem:\n            vectors = re.findall(r'cross\\(\\[(.*?)\\], \\[(.*?)\\]\\)', problem)\n            if vectors:\n                vec_a = sp.Matrix([sp.sympify(i) for i in vectors[0][0].split(',')])\n                vec_b = sp.Matrix([sp.sympify(i) for i in vectors[0][1].split(',')])\n                return vec_a.cross(vec_b).tolist()\n\n        if 'inverse' in problem:\n            matrices = re.findall(r'inverse\\(\\[(.*)\\]\\)', problem)\n            if matrices:\n                mat = sp.Matrix([[sp.sympify(num) for num in row.split(',')] for row in matrices[0].split('],[')])\n                return mat.inv().tolist()\n\n        # Basic simplification of problem statement\n        problem = re.sub(r'[^\\w\\s=,()\\-+*/.^]', '', problem).replace('\\n', ' ').strip()\n        problem_expr = sp.sympify(problem)\n\n        if \"solve\" in problem:\n            return sp.solve(problem_expr, vars)\n\n        if 'diff' in problem:\n            return [sp.diff(problem_expr, var) for var in vars]\n\n        if 'integrate' in problem:\n            return [sp.integrate(problem_expr, var) for var in vars]\n\n        return sp.simplify(problem_expr)\n\n    except Exception as e:\n        return f'Error processing task: {e}'",
    "packages": "sympy"
  }
}