[
  {
    "action": "add",
    "target": {
      "code": "from sympy import sympify, simplify, SympifyError\n\ndef evaluate_math_expressions(expression):\n    try:\n        # Convert the expression into a sympy expression\n        expr = sympify(expression)\n        \n        # Simplify the expression to its simplest exact form\n        # Ensure result being evaluated can handle fractions/radicals as needed\n        result = simplify(expr)\n\n        if hasattr(result, 'evalf') and result.is_number:\n            return result.evalf()\n\n        return str(result)\n    except SympifyError as e:\n        return f\"Error simplifying expression: {e}\"",
      "description": "Evaluate arithmetic or mathematical expressions using sympy, focusing on providing exact answers with fractions or radicals when possible.",
      "name": "evaluate_math_expressions",
      "packages": "sympy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "from sympy import Matrix\n\ndef matrix_operations(matrix_a, matrix_b=None, operation='multiply'):\n    try:\n        A = Matrix(matrix_a)\n\n        if operation == 'multiply':\n            if matrix_b:\n                B = Matrix(matrix_b)\n                return A * B\n            else:\n                return \"Matrix B is required for multiplication.\"\n        elif operation == 'determinant':\n            return A.det()\n        elif operation == 'inverse':\n            if A.det() != 0:\n                return A.inv()\n            else:\n                return \"Matrix is not invertible.\"\n        else:\n            return \"Invalid operation specified.\"\n    except Exception as e:\n        return str(e)",
      "description": "Perform operations on matrices such as multiplication, determinant calculation, and finding the inverse.",
      "name": "matrix_operations",
      "packages": "sympy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "from sympy import symbols, solve, simplify, sympify, SympifyError, Rational, N, Eq, Matrix\nimport re\n\ndef solve_math_problem(problem, variables=None):\n    try:\n        # Define generic symbols if no variables are explicitly provided\n        if variables:\n            vars = symbols(' '.join(variables))\n        else:\n            vars = symbols('x y z')\n            \n        # Preprocess and normalize the problem string for parsing\n        problem = problem.replace('\\n', ' ').strip()\n\n        # Regex patterns for common operations tasks\n        if \"system of equations\" in problem.lower() or \"intersection\" in problem.lower():\n            # Extract equations and solve\n            equations = re.findall(r'([-+]?[0-9]*\\.?[0-9]+[a-zA-Z]*[\\=<>!]+[-+]?\\(?[0-9]*\\.?[0-9]*[a-zA-Z]*\\)?)', problem)\n            eq_list = [Eq(sympify(eq.split('=')[0].strip()), sympify(eq.split('=')[1].strip())) for eq in equations]\n            # Solve the system of equations\n            result = solve(eq_list, vars)\n            return result if result else \"No solutions/steps found.\"\n        elif \"simplify\" in problem.lower():\n            expr = sympify(problem.replace(\"simplify \", \"\"))\n            result = simplify(expr)\n            return f\"Simplified expression: {result}\"\n        else:\n            # Tokenize sentences to operate sequential tasks\n            steps = re.split('(solve|calculate|evaluate|simplify)', problem, flags=re.IGNORECASE)\n            results = []\n            for step in steps:\n                if 'solve' in step.lower() and '=' in step:\n                    equation = sympify(step.split(':')[-1].strip())\n                    solution = solve(equation, vars)\n                    results.append(f\"Solution: {solution}\")\n                elif 'expression' in step or any(o in step for o in ['+', '-', '*', '/']):\n                    expr = sympify(step)\n                    result = simplify(expr)\n                    numerical_result = N(result)\n                    if result.is_number:\n                        results.append(f\"Result: {numerical_result}\")\n                    else:\n                        results.append(f\"Symbolic Result: {result}\")\n                else:\n                    if step.strip():  # Handle remaining or unclear outputs\n                        expr = sympify(step)\n                        results.append(f\"Evaluation: {expr}\")\n            return results if results else \"No solutions/steps found.\"\n    except (SympifyError, TypeError, ValueError) as e:\n        return f\"An error occurred while processing the problem: {e}\"",
      "description": "Solve mathematical problems using step-by-step approach with sympy, handling equations and returning computation steps with numerical verification. Allows specifying variables explicitly for solving systems of equations. This version improves code efficiency and parsing of problems for more reliable outputs.",
      "name": "solve_math_problem",
      "packages": "sympy"
    }
  }
]