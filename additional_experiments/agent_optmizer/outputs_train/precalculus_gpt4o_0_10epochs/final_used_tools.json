{
  "evaluate_cross_product": {
    "code": "from sympy import Matrix\n\ndef evaluate_cross_product(vector_a, vector_b):\n    try:\n        vec_a = Matrix(vector_a)\n        vec_b = Matrix(vector_b)\n        cross_product = vec_a.cross(vec_b)\n        return list(cross_product)\n    except Exception as e:\n        return str(e)",
    "packages": "sympy"
  },
  "evaluate_inverse_trig_expressions": {
    "code": "from sympy import sympify, asin, acos, atan, pi, simplify\n\n\ndef evaluate_inverse_trig_expressions(expression):\n    try:\n        expr = sympify(expression)\n        result = expr.evalf()\n        if isinstance(expr, (asin, acos, atan)):\n            return simplify(expr)\n        return result\n    except Exception as e:\n        return str(e)",
    "packages": "sympy"
  },
  "evaluate_math_expressions": {
    "code": "from sympy import sympify, simplify, SympifyError\n\ndef evaluate_math_expressions(expression):\n    try:\n        # Convert the expression into a sympy expression\n        expr = sympify(expression)\n        \n        # Simplify the expression to its simplest exact form\n        # Ensure result being evaluated can handle fractions/radicals as needed\n        result = simplify(expr)\n\n        if hasattr(result, 'evalf') and result.is_number:\n            return result.evalf()\n\n        return str(result)\n    except SympifyError as e:\n        return f\"Error simplifying expression: {e}\"",
    "packages": "sympy"
  },
  "evaluate_matrix_expression": {
    "code": "from sympy import Matrix\n\ndef evaluate_matrix_expression(matrix_a, matrix_b=None, operation='multiply'):\n    try:\n        mat_a = Matrix(matrix_a)\n        if operation == 'invert':\n            result = mat_a.inv()\n        elif operation == 'add' and matrix_b is not None:\n            mat_b = Matrix(matrix_b)\n            result = mat_a + mat_b\n        elif operation == 'multiply' and matrix_b is not None:\n            mat_b = Matrix(matrix_b)\n            result = mat_a * mat_b\n        else:\n            return 'Unsupported operation or missing matrix for operation.'\n        return result.tolist()\n    except Exception as e:\n        return str(e)",
    "packages": "sympy"
  },
  "evaluate_trig_expressions": {
    "code": "from sympy import sympify, pi, simplify, rad, deg, sin, cos, tan, asin, acos, atan\nfrom sympy.parsing.sympy_parser import parse_expr, standard_transformations, implicit_multiplication_application\nfrom sympy.core.sympify import SympifyError\n\ntransformations = standard_transformations + (implicit_multiplication_application,)\n\ndef evaluate_trig_expressions(expression: str):\n    try:\n        # Replace degree symbol and the word 'degrees' with radians\n        expression = expression.replace('\u00b0', '*pi/180').replace('degrees', '*pi/180')\n        # Parse the expression considering implicit multiplications\n        expr = parse_expr(expression, transformations=transformations)\n        # Evaluate the expression\n        result = expr.evalf()\n        return float(result)\n    except SympifyError as e:\n        return \"Error parsing or evaluating expression: {}\".format(e)\n    except Exception as e:\n        return str(e)",
    "packages": "sympy"
  },
  "matrix_operations": {
    "code": "from sympy import Matrix\n\ndef matrix_operations(matrix_a, matrix_b=None, operation='multiply'):\n    try:\n        mat_a = Matrix(matrix_a)\n        if operation == 'invert':\n            result = mat_a.inv()\n        elif operation == 'add' and matrix_b is not None:\n            mat_b = Matrix(matrix_b)\n            result = mat_a + mat_b\n        elif operation == 'multiply' and matrix_b is not None:\n            mat_b = Matrix(matrix_b)\n            result = mat_a * mat_b\n        else:\n            return 'Unsupported operation or missing matrix for operation.'\n        return result.tolist()\n    except Exception as e:\n        return str(e)",
    "packages": "sympy"
  },
  "solve_math_problem": {
    "code": "import sympy as sp\nimport re\n\ndef solve_math_problem(problem: str, variables=None):\n    try:\n        # Define symbols for the variables if provided\n        if variables:\n            vars = sp.symbols(' '.join(variables), real=True)\n        else:\n            vars = sp.symbols('x y z', real=True)  # Default symbols\n\n        # Basic simplification of problem statement\n        problem = problem.replace('\\n', ' ').strip()\n\n        # Check for specific operations and solve accordingly\n        if 'cross' in problem:\n            vectors = re.findall(r'cross\\(\\[(.*?)\\], \\[(.*?)\\]\\)', problem)\n            if vectors:\n                vec_a = sp.Matrix([sp.sympify(i) for i in vectors[0][0].split(',')])\n                vec_b = sp.Matrix([sp.sympify(i) for i in vectors[0][1].split(',')])\n                return vec_a.cross(vec_b).tolist()\n\n        if 'inverse' in problem:\n            matrices = re.findall(r'inverse\\(\\[(.*)\\]\\)', problem)\n            if matrices:\n                mat = sp.Matrix([[sp.sympify(num) for num in row.split(',')] for row in matrices[0].split('],[')])\n                return mat.inv().tolist()\n\n        if \"solve\" in problem:\n            problem_expr = sp.sympify(problem)\n            return sp.solve(problem_expr, vars)\n\n        if 'diff' in problem or 'differentiate' in problem:\n            # Perform differentiation\n            for var in vars:\n                try:\n                    result = sp.diff(sp.sympify(problem), var)\n                    return result\n                except Exception as e:\n                    return str(e)\n\n        if 'integrate' in problem:\n            # Perform integration\n            for var in vars:\n                try:\n                    result = sp.integrate(sp.sympify(problem), var)\n                    return result\n                except Exception as e:\n                    return str(e)\n\n        return 'Computational steps not clearly defined within input problem.'\n    except Exception as e:\n        return f'Error processing task: {e}'",
    "packages": "sympy"
  },
  "solve_trigonometric_identity": {
    "code": "from sympy import sin, cos, tan, simplify\n\ndef solve_trigonometric_identity(expression):\n    try:\n        expr = sympify(expression)\n        simplified_expr = simplify(expr)\n        return str(simplified_expr)\n    except Exception as e:\n        return str(e)",
    "packages": "sympy"
  }
}