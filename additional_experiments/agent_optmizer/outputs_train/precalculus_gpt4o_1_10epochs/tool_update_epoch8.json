[
  {
    "action": "add",
    "target": {
      "code": "import sympy as sp\n\ndef solve_triangle_angles(side_a, side_b, side_c):\n    a = sp.sympify(side_a)\n    b = sp.sympify(side_b)\n    c = sp.sympify(side_c)\n\n    # Calculate cosines using the Law of Cosines\n    cos_A = (b**2 + c**2 - a**2) / (2 * b * c)\n    cos_B = (a**2 + c**2 - b**2) / (2 * a * c)\n    cos_C = (a**2 + b**2 - c**2) / (2 * a * b)\n\n    # Calculate angles in degrees\n    angle_A = sp.acos(cos_A) * 180 / sp.pi\n    angle_B = sp.acos(cos_B) * 180 / sp.pi\n    angle_C = sp.acos(cos_C) * 180 / sp.pi\n\n    return (angle_A.evalf(), angle_B.evalf(), angle_C.evalf())",
      "description": "Solve for the angles of a triangle given its side lengths using the Law of Cosines.",
      "name": "solve_triangle_angles",
      "packages": "sympy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "from sympy import Matrix\n\ndef compute_vector_projection(v, w):\n    v = Matrix(v)\n    w = Matrix(w)\n    dot_vw = v.dot(w)\n    dot_ww = w.dot(w)\n    proj_v_on_w = (dot_vw / dot_ww) * w\n    return proj_v_on_w.tolist()",
      "description": "Compute the projection of vector v onto vector w using the dot product.",
      "name": "compute_vector_projection",
      "packages": "sympy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "from sympy import sympify, sqrt, atan2, acos, pi\n\ndef convert_coordinates_to_spherical(x, y, z):\n    x, y, z = sympify(x), sympify(y), sympify(z)\n    rho = sqrt(x**2 + y**2 + z**2)\n    theta = atan2(y, x)\n    if theta < 0:\n        theta += 2 * pi\n    phi = acos(z / rho)\n    return rho, theta, phi",
      "description": "Convert a point from rectangular coordinates to spherical coordinates (rho, theta, phi) where rho > 0, 0 <= theta < 2*pi, and 0 <= phi <= pi.",
      "name": "convert_coordinates_to_spherical",
      "packages": "sympy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "from sympy import Matrix, sympify, gcd as sympy_gcd\n\ndef find_plane_equation_from_points(point1, point2, point3):\n    # Convert points to sympy vector format\n    p1 = Matrix([sympify(coord) for coord in point1])\n    p2 = Matrix([sympify(coord) for coord in point2])\n    p3 = Matrix([sympify(coord) for coord in point3])\n\n    # Create vectors from points\n    v1 = p2 - p1\n    v2 = p3 - p1\n\n    # Calculate the normal vector through cross product\n    normal_vector = v1.cross(v2)\n    A, B, C = normal_vector\n\n    # Calculate D using a point from the plane\n    D = -(A*p1[0] + B*p1[1] + C*p1[2])\n\n    # Ensure integers as output and gcd(A,B,C,D) = 1 while A > 0\n    gcd_val = sympy_gcd(A, sympy_gcd(B, sympy_gcd(C, D)))\n    A, B, C, D = A/gcd_val, B/gcd_val, C/gcd_val, D/gcd_val\n    if A < 0:\n        A, B, C, D = -A, -B, -C, -D\n\n    return A, B, C, D",
      "description": "Find the equation of a plane given three points in 3D space. The result is simplified to integers where applicable, ensuring greatest common divisor of coefficients is 1.",
      "name": "find_plane_equation_from_points",
      "packages": "sympy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "from sympy import symbols, Eq, solve, simplify, sympify, atan2, acos, sqrt, pi, Matrix\n\ndef solve_question_with_sympy(problem_description, variables):\n    try:\n        # Ensure problem description includes valid mathematical operations\n        problem_lower = problem_description.lower()\n        symbols_list = symbols(variables)\n        \n        # Check for coordinate conversion\n        if 'convert coordinates' in problem_lower:\n            coords_str = problem_description.split('(')[-1].split(')')[0]\n            x, y, z = map(sympify, coords_str.split(','))\n            rho = sqrt(x**2 + y**2 + z**2)\n            theta = atan2(y, x)\n            if theta < 0:\n                theta += 2 * pi\n            phi = acos(z / rho)\n            return (rho, theta, phi)\n\n        # Simplified parsing with equation and intersection problems\n        elif 'intersection' in problem_lower or any(op in problem_lower for op in ['=', 'and', 'or']):\n            eqs = problem_description.replace(' and ', ',').split(',')\n            equations = []\n            for eq in eqs:\n                if '=' in eq:\n                    lhs, rhs = eq.split('=')\n                    equations.append(Eq(simplify(sympify(lhs.strip())), simplify(sympify(rhs.strip()))))\n            solution = solve(equations, symbols_list, dict=True)\n            return solution if solution else \"No solution found.\"\n\n        # Expression evaluation\n        else:\n            sym_expr = sympify(problem_description)\n            solution = solve(sym_expr, symbols_list, dict=True)\n            return solution if solution else \"Solved without result.\"\n\n    except Exception as e:\n        return f\"Error occurred: {str(e)}\"\n",
      "description": "Solve a wide range of mathematical problems such as solving equations, converting coordinates, evaluating expressions, and finding intersections or projections using SymPy. Enhanced for better parsing and computation of symbolic or numerical results. This version fixes issues related to the preceding definition and corrects exceptions for improved versatility across equation, intersection, and conversion tasks.",
      "name": "solve_question_with_sympy",
      "packages": "sympy"
    }
  }
]