{
  "calculate_average_cost": {
    "code": "def calculate_average_cost(quantities, prices):\n    if len(quantities) != len(prices):\n        return \"Error: Length of quantities and prices must match.\"\n    total_cost = sum(q * p for q, p in zip(quantities, prices))\n    total_quantity = sum(quantities)\n    return total_cost / total_quantity if total_quantity > 0 else 0",
    "packages": "sympy"
  },
  "calculate_costs_and_weights": {
    "code": "from sympy import symbols, solve\n\ndef calculate_costs_and_weights(corn_weight, beans_weight, total_weight, total_cost):\n    x = symbols('x')\n    y = total_weight - x\n    cost = 0.99 * x + 0.45 * y\n    return cost == total_cost",
    "packages": "sympy"
  },
  "calculate_distance": {
    "code": "from sympy import sqrt\n\ndef calculate_distance(point1, point2):\n    if len(point1) != 2 or len(point2) != 2:\n        return \"Error: Each point must have exactly 2 coordinates.\"\n    x1, y1 = point1\n    x2, y2 = point2\n    distance = sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    return float(distance.evalf())",
    "packages": "sympy"
  },
  "calculate_distance_general": {
    "code": "from sympy import sqrt\n\ndef calculate_distance_general(point1, point2):\n    if len(point1) != 2 or len(point2) != 2:\n        return \"Error: Each point must have exactly 2 coordinates.\"\n    x1, y1 = point1\n    x2, y2 = point2\n    distance = sqrt((x2 - x1)**2 + (y2 - y1)**2)\n    return distance.expand().simplify()",
    "packages": "sympy"
  },
  "calculate_equation_fill_fraction": {
    "code": "from sympy import symbols, Rational, Eq, solve\n\ndef calculate_equation_fill_fraction(current_fill_fraction, target_fill_fraction, additional_liters):\n    V = symbols('V')\n    current_fill = Rational(int(current_fill_fraction.split('/')[0]), int(current_fill_fraction.split('/')[1])) * V\n    target_fill = Rational(int(target_fill_fraction.split('/')[0]), int(target_fill_fraction.split('/')[1])) * V\n    equation = Eq(current_fill + additional_liters, target_fill)\n    return solve(equation, V)[0]",
    "packages": "sympy"
  },
  "calculate_geometric_progression": {
    "code": "def calculate_geometric_progression():\n    largest_geo_number = 0\n    \n    # Loop through digit a from 9 to 1\n    for a in range(9, 0, -1):\n        for r in range(1, 10):  # Possible values for the common ratio\n            b = a * r\n            c = a * r * r\n            if b < 10 and c < 10:\n                # Check if all digits are distinct\n                if len(set([a, b, c])) == 3:\n                    number = a * 100 + b * 10 + c\n                    if number > largest_geo_number:\n                        largest_geo_number = number\n    return largest_geo_number",
    "packages": ""
  },
  "calculate_geometric_sequence": {
    "code": "def calculate_geometric_sequence(first_term, second_term):\n    if first_term == 0:\n        return 'Error: First term cannot be zero.'\n    ratio = second_term / first_term\n    return ratio",
    "packages": "sympy"
  },
  "calculate_specific_statistics": {
    "code": "from sympy import symbols, solve\n\ndef calculate_specific_statistics(corn_weight, beans_weight, total_weight, total_cost):\n    x = symbols('x')\n    y = total_weight - x\n    cost = 0.99 * x + 0.45 * y\n    return (cost, solve(cost - total_cost, x))",
    "packages": "sympy"
  },
  "calculate_time_of_travel": {
    "code": "def calculate_time_of_travel(distance, speed):\n    if speed <= 0:\n        return 'Error: Speed must be greater than zero.'\n    return distance / speed",
    "packages": "sympy"
  },
  "calculate_total_cost": {
    "code": "def calculate_total_cost(quantities, prices):\n    if len(quantities) != len(prices):\n        return \"Error: Length of quantities and prices must match.\"\n    return sum(q * p for q, p in zip(quantities, prices))",
    "packages": "sympy"
  },
  "calculate_volume_after_addition": {
    "code": "from sympy import symbols, Rational, Eq, solve\n\ndef calculate_volume_after_addition(current_fill_fraction, target_fill_fraction, additional_liters):\n    V = symbols('V')\n    current_fill = Rational(int(current_fill_fraction.split('/')[0]), int(current_fill_fraction.split('/')[1])) * V\n    target_fill = Rational(int(target_fill_fraction.split('/')[0]), int(target_fill_fraction.split('/')[1])) * V\n    equation = Eq(current_fill + additional_liters, target_fill)\n    return float(solve(equation, V)[0])",
    "packages": "sympy"
  },
  "cylinder_volume": {
    "code": "from sympy import symbols, Rational, Eq, solve\n\ndef cylinder_volume(current_fill_fraction, additional_liters, target_fill_fraction):\n    V = symbols('V')\n    current_fill = Rational(int(current_fill_fraction.split('/')[0]), int(current_fill_fraction.split('/')[1])) * V\n    target_fill = Rational(int(target_fill_fraction.split('/')[0]), int(target_fill_fraction.split('/')[1])) * V\n    equation = Eq(current_fill + additional_liters, target_fill)\n    return solve(equation, V)[0]",
    "packages": "sympy"
  },
  "evaluate_arithmetic_expression": {
    "code": "from sympy import sympify, SympifyError\n\ndef evaluate_arithmetic_expression(expression):\n    try:\n        result = sympify(expression)\n        return result.evalf() if result.is_number else str(result)\n    except SympifyError:\n        return 'Error: Invalid expression.'",
    "packages": "sympy"
  },
  "evaluate_expression": {
    "code": "from sympy import sympify, SympifyError\n\ndef evaluate_expression(expression):\n    try:\n        result = sympify(expression)\n        if result.is_number:\n            result = float(result)\n        else:\n            result = str(result)\n        return result\n    except SympifyError as e:\n        return str(e)",
    "packages": "sympy"
  },
  "evaluate_mathematical_expression": {
    "code": "from sympy import sympify, SympifyError\n\ndef evaluate_mathematical_expression(expression):\n    try:\n        result = sympify(expression)\n        return result.evalf() if result.is_number else str(result)\n    except SympifyError:\n        return 'Error: Invalid expression.'",
    "packages": "sympy"
  },
  "execute_function": {
    "code": "def execute_function(functionName, args):\n    if functionName == 'calculate_distance':\n        return calculate_distance(**args)\n    if functionName == 'calculate_total_cost':\n        return calculate_total_cost(**args)\n    if functionName == 'calculate_volume_after_addition':\n        return calculate_volume_after_addition(**args)\n    if functionName == 'cylinder_volume':\n        return cylinder_volume(**args)\n    if functionName == 'calculate_equation_fill_fraction':\n        return calculate_equation_fill_fraction(**args)\n    if functionName == 'calculate_time_of_travel':\n        return calculate_time_of_travel(**args)\n    return 'Error: Function not found.'",
    "packages": ""
  },
  "solve_linear_equation": {
    "code": "from sympy import symbols, Eq, solve\n\ndef solve_linear_equation(corn_weight, beans_weight, total_weight, total_cost):\n    x = symbols('x')\n    y = total_weight - x\n    cost = 0.99 * x + 0.45 * y\n    if cost == total_cost:\n        return (x, y)\n    return None",
    "packages": "sympy"
  },
  "solve_linear_equation_system": {
    "code": "from sympy import symbols, Eq, solve\n\ndef solve_linear_equation_system(eq1, eq2):\n    x, y = symbols('x y')\n    equation1 = Eq(eval(eq1), 0)\n    equation2 = Eq(eval(eq2), 0)\n    return solve((equation1, equation2), (x, y))",
    "packages": "sympy"
  },
  "solve_linear_system": {
    "code": "from sympy import symbols, Eq, solve\n\ndef solve_linear_system(eq1, eq2):\n    c, b = symbols('c b')\n    equation1 = Eq(eval(eq1), eval(eq2))\n    return solve([equation1])",
    "packages": "sympy"
  },
  "solve_system_of_equations": {
    "code": "from sympy import symbols, Eq, solve\n\ndef solve_system_of_equations(equations):\n    variables = symbols(' '.join(['var'+str(i) for i in range(len(equations))]))\n    eqs = []\n    for i, eq in enumerate(equations):\n        eqs.append(Eq(eval(eq), 0))\n    return solve(eqs, variables)",
    "packages": "sympy"
  }
}