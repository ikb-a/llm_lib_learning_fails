{
  "calculate_combinations": {
    "code": "from sympy import binomial\n\ndef calculate_combinations(n, k):\n    if n < k:\n        return 0\n    return binomial(n, k)",
    "packages": "sympy"
  },
  "calculate_expected_rolls": {
    "code": "def calculate_expected_rolls(total_rolls):\n    from sympy import symbols, Eq, solve\n\n    if total_rolls < 0:\n        raise ValueError('Total rolls must be a non-negative integer')\n\n    # Define the equation based on expected rolls for specific conditions\n    E = symbols('E')\n    eq1 = Eq(E, (2/6) * 1 + (3/6) * 1 + (1/6) * (E + 1))\n    expected_rolls = solve(eq1, E)[0]\n    return expected_rolls * total_rolls",
    "packages": "sympy"
  },
  "calculate_expected_rolls_for_year": {
    "code": "def calculate_expected_rolls_for_year(daily_expected_rolls):\n    if not isinstance(daily_expected_rolls, int) or daily_expected_rolls < 0:\n        raise ValueError('daily_expected_rolls must be a non-negative integer')\n    return daily_expected_rolls * 365",
    "packages": "numpy"
  },
  "calculate_expected_rolls_in_year": {
    "code": "def calculate_expected_rolls_in_year(daily_expected_rolls):\n    total_days = 365\n    if not isinstance(daily_expected_rolls, int) or daily_expected_rolls < 0:\n        raise ValueError('daily_expected_rolls must be a non-negative integer')\n    return daily_expected_rolls * total_days",
    "packages": "numpy"
  },
  "calculate_expected_rolls_in_year_non_leap": {
    "code": "def calculate_expected_rolls_in_year_non_leap(daily_expected_rolls):\n    if not isinstance(daily_expected_rolls, int) or daily_expected_rolls < 0:\n        raise ValueError('daily_expected_rolls must be a non-negative integer')\n    return daily_expected_rolls * 365",
    "packages": "numpy"
  },
  "calculate_expected_rolls_per_year": {
    "code": "def calculate_expected_rolls_per_year(expected_rolls_per_day):\n    if not isinstance(expected_rolls_per_day, int) or expected_rolls_per_day < 0:\n        raise ValueError('expected_rolls_per_day must be a non-negative integer')\n    return expected_rolls_per_day * 365",
    "packages": "numpy"
  },
  "calculate_expected_value": {
    "code": "def calculate_expected_value(total_rolls_per_year):\n    from sympy import symbols, Eq, solve\n    # Check for valid input\n    if not isinstance(total_rolls_per_year, int) or total_rolls_per_year < 0:\n        raise ValueError('total_rolls_per_year must be a non-negative integer')\n    # Define the variable for expected value\n    E = symbols('E')\n    # Set up the equation based on the problem description\n    equation = Eq(E, (1/3) + (1/2) + (1/6) * (E + 1))\n    expected_value = solve(equation, E)[0]\n    return expected_value * total_rolls_per_year;",
    "packages": "sympy"
  },
  "calculate_expected_value_of_dice_rolls": {
    "code": "from sympy import Rational\n\n\ndef calculate_expected_value_of_dice_rolls(total_rolls_per_year):\n    E = Rational(6, 5)\n    return E * total_rolls_per_year",
    "packages": "sympy"
  },
  "calculate_probability": {
    "code": "def calculate_probability(total_outcomes, favorable_outcomes):\n    from sympy import Rational\n    if total_outcomes <= 0:\n        raise ValueError('Total outcomes must be a positive integer')\n    return Rational(favorable_outcomes, total_outcomes).limit_denominator()",
    "packages": "sympy"
  },
  "calculate_probability_of_at_least_two_identical_rolls": {
    "code": "def calculate_probability_of_at_least_two_identical_rolls(number_of_dice, sides_per_die):\n    from sympy import Rational, factorial\n    if number_of_dice <= 0:\n        raise ValueError('Number of dice must be positive.')\n    if sides_per_die <= 1:\n        raise ValueError('Each die must have at least 2 sides.')\n\n    total_outcomes = sides_per_die ** number_of_dice\n    favorable_outcomes = factorial(sides_per_die) / factorial(sides_per_die - number_of_dice) if number_of_dice <= sides_per_die else 0\n\n    return 1 - Rational(favorable_outcomes, total_outcomes)",
    "packages": "sympy"
  },
  "calculate_probability_of_event": {
    "code": "def calculate_probability_of_event(total_outcomes, favorable_outcomes):\n    from sympy import Rational\n    if total_outcomes <= 0:\n        raise ValueError('Total outcomes must be a positive integer')\n    return Rational(favorable_outcomes, total_outcomes).limit_denominator()",
    "packages": "sympy"
  },
  "calculate_probability_of_non_six_dice": {
    "code": "from sympy import Rational\n\ndef calculate_probability_of_non_six_dice(total_rolls, six_sided):\n    if six_sided:\n        return Rational(1, 6) * total_rolls\n    else:\n        # Assuming two-color scenario, update accordingly\n        return Rational(3, 12) * total_rolls",
    "packages": "sympy"
  },
  "calculate_probability_using_counts": {
    "code": "from sympy import Rational\n\ndef calculate_probability_using_counts(total_count, favorable_count):\n    '''Calculate the probability from total and favorable counts.'''  \n    if total_count <= 0:\n        raise ValueError('Total count must be greater than zero.')\n    return Rational(favorable_count, total_count).limit_denominator()",
    "packages": "sympy"
  },
  "calculate_total_expected_rolls": {
    "code": "def calculate_total_expected_rolls(daily_expected_rolls):\n    if not isinstance(daily_expected_rolls, int) or daily_expected_rolls < 0:\n        raise ValueError('daily_expected_rolls must be a non-negative integer')\n    total_days = 365\n    return daily_expected_rolls * total_days",
    "packages": "sympy"
  },
  "dice_roll_experiment": {
    "code": "from sympy import symbols, Eq, solve\n\n# Define the expected value as a function\n\ndef expected_value_of_rolls():\n    E = symbols('E')\n    # Set up the equation based on the problem description\n    equation = Eq(E, (1/3) + (1/2) + (1/6) * (E + 1))\n    expected_value = solve(equation, E)[0]\n    return expected_value",
    "packages": "sympy"
  },
  "expected_rolls_in_year": {
    "code": "def expected_rolls_in_year(daily_expected_rolls):\n    days_in_year = 365\n    total_expected_rolls = daily_expected_rolls * days_in_year\n    return total_expected_rolls",
    "packages": "numpy"
  },
  "expected_value_of_dice_rolls": {
    "code": "def expected_value_of_dice_rolls():\n   from sympy import symbols, Eq, solve\n   # Define the variable for expected value\n   E = symbols('E')\n   # Set up the equation based on the problem description\n   equation = Eq(E, (1/3) + (1/2) + (1/6) * (E + 1))\n   expected_value = solve(equation, E)[0]\n   return expected_value",
    "packages": "sympy"
  },
  "expected_value_of_rolls": {
    "code": "from sympy import symbols, Eq, solve\n\ndef expected_value_of_rolls(total_rolls):\n    '''Calculate the expected number of rolls when rolling a die given the rules.'''  \n    E = symbols('E')\n    equation = Eq(E, (1/2) * (1 + E) + (1/3) * 1 + (1/6) * 1)\n    expected_value = solve(equation, E)[0]\n    return expected_value * total_rolls",
    "packages": "sympy"
  },
  "expected_value_of_rolls_in_year": {
    "code": "def expected_value_of_rolls_in_year(daily_expected_rolls, year_length):\n    return daily_expected_rolls * year_length",
    "packages": "numpy"
  }
}