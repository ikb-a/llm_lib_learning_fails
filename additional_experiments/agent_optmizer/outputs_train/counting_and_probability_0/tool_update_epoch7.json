[
  {
    "action": "add",
    "target": {
      "code": "def calculate_probability(total_outcomes, favorable_outcomes):\n    from sympy import Rational\n    return Rational(favorable_outcomes, total_outcomes).limit_denominator()",
      "description": "Calculates the probability of drawing items based on defined outcomes and conditions.",
      "name": "calculate_probability",
      "packages": "sympy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "def calculate_total_expected_rolls(daily_expected_rolls):\n    if not isinstance(daily_expected_rolls, int) or daily_expected_rolls < 0:\n        raise ValueError('daily_expected_rolls must be a non-negative integer')\n    total_days = 365\n    return daily_expected_rolls * total_days",
      "description": "Calculate the total expected number of rolls in a non-leap year based on daily expected rolls.",
      "name": "calculate_total_expected_rolls",
      "packages": "sympy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "from sympy import symbols, Eq, solve\n\n# Define the expected value as a function\n\ndef expected_value_of_rolls():\n    E = symbols('E')\n    # Set up the equation based on the problem description\n    equation = Eq(E, (1/3) + (1/2) + (1/6) * (E + 1))\n    expected_value = solve(equation, E)[0]\n    return expected_value",
      "description": "Calculate the expected number of rolls when rolling a die with specific rules about outcomes.",
      "name": "dice_roll_experiment",
      "packages": "sympy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "def calculate_expected_value(total_rolls_per_year):\n   from sympy import symbols, Eq, solve\n   # Check for valid input\n   if not isinstance(total_rolls_per_year, int) or total_rolls_per_year < 0:\n       raise ValueError('total_rolls_per_year must be a non-negative integer')\n   # Define the variable for expected value\n   E = symbols('E')\n   # Set up the equation based on the problem description\n   equation = Eq(E, (1/3) + (1/2) + (1/6) * (E + 1))\n   expected_value = solve(equation, E)[0]\n   return expected_value * total_rolls_per_year",
      "description": "Calculate the expected value of the number of rolls when rolling a die with specific rules about outcomes.",
      "name": "calculate_expected_value",
      "packages": "sympy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "def expected_value_of_dice_rolls():\n   from sympy import symbols, Eq, solve\n   # Define the variable for expected value\n   E = symbols('E')\n   # Set up the equation based on the problem description\n   equation = Eq(E, (1/3) + (1/2) + (1/6) * (E + 1))\n   expected_value = solve(equation, E)[0]\n   return expected_value",
      "description": "Calculate the expected value based on the outcomes of rolling a die with specific rules about outcomes.",
      "name": "expected_value_of_dice_rolls",
      "packages": "sympy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "def calculate_probability_of_event(total_outcomes, favorable_outcomes):\n    from sympy import Rational\n    if total_outcomes <= 0:\n        raise ValueError('Total outcomes must be a positive integer')\n    return Rational(favorable_outcomes, total_outcomes).limit_denominator()",
      "description": "Calculate the probability of a specific event occurring based on total and favorable outcomes.",
      "name": "calculate_probability_of_event",
      "packages": "sympy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "def calculate_expected_rolls(total_rolls):\n    from sympy import symbols, Eq, solve\n\n    if total_rolls < 0:\n        raise ValueError('Total rolls must be a non-negative integer')\n\n    # Define the equation based on expected rolls for specific conditions\n    E = symbols('E')\n    eq1 = Eq(E, (2/6) * 1 + (3/6) * 1 + (1/6) * (E + 1))\n    expected_rolls = solve(eq1, E)[0]\n    return expected_rolls * total_rolls",
      "description": "Calculate expected number of times a die is rolled with specific conditions, using the complement rule.",
      "name": "calculate_expected_rolls",
      "packages": "sympy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "def calculate_expected_rolls_for_year(daily_expected_rolls):\n    if not isinstance(daily_expected_rolls, int) or daily_expected_rolls < 0:\n        raise ValueError('daily_expected_rolls must be a non-negative integer')\n    return daily_expected_rolls * 365",
      "description": "Calculate the expected number of rolls in a year based on a specific daily expected rolls input and the number of days in a year.",
      "name": "calculate_expected_rolls_for_year",
      "packages": "numpy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "def calculate_expected_rolls_in_year_non_leap(daily_expected_rolls):\n    if not isinstance(daily_expected_rolls, int) or daily_expected_rolls < 0:\n        raise ValueError('daily_expected_rolls must be a non-negative integer')\n    return daily_expected_rolls * 365",
      "description": "Calculate the expected number of rolls in a non-leap year based on daily expected rolls.",
      "name": "calculate_expected_rolls_in_year_non_leap",
      "packages": "numpy"
    }
  },
  {
    "action": "add",
    "target": {
      "code": "def calculate_expected_rolls_in_year(daily_expected_rolls):\n    total_days = 365\n    if not isinstance(daily_expected_rolls, int) or daily_expected_rolls < 0:\n        raise ValueError('daily_expected_rolls must be a non-negative integer')\n    return daily_expected_rolls * total_days",
      "description": "Calculate the expected number of rolls in a non-leap year based on daily expected rolls.",
      "name": "calculate_expected_rolls_in_year",
      "packages": "numpy"
    }
  }
]